import { jsPDF } from "jspdf";
import autoTable from "jspdf-autotable";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import ELRAWallet from "../models/ELRAWallet.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class TransactionReportService {
  constructor() {
    this.reportsDir = path.join(__dirname, "../uploads/transaction-reports");
    this.ensureReportsDirectory();
  }

  ensureReportsDirectory() {
    if (!fs.existsSync(this.reportsDir)) {
      fs.mkdirSync(this.reportsDir, { recursive: true });
    }
  }

  /**
   * Generate transaction history PDF report
   */
  async generateTransactionReport(transactions, filters = {}, userInfo = {}) {
    try {
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
      const fileName = `transaction_report_${timestamp}.pdf`;
      const filePath = path.join(this.reportsDir, fileName);

      // Get the actual wallet data for accurate budget allocation
      const wallet = await ELRAWallet.findOne({ elraInstance: "ELRA_MAIN" });
      const walletBudgetData = wallet?.budgetCategories || {};

      const doc = new jsPDF({
        orientation: "portrait",
        unit: "mm",
        format: "a4",
      });

      this.generateReportContent(
        doc,
        transactions,
        filters,
        userInfo,
        walletBudgetData
      );

      const pdfBytes = doc.output("arraybuffer");
      fs.writeFileSync(filePath, Buffer.from(pdfBytes));

      return {
        fileName,
        filePath,
        url: `/uploads/transaction-reports/${fileName}`,
      };
    } catch (error) {
      console.error(
        "❌ [TRANSACTION REPORT SERVICE] Error generating PDF:",
        error
      );
      throw error;
    }
  }

  /**
   * Generate the PDF content
   */
  generateReportContent(
    doc,
    transactions,
    filters,
    userInfo,
    walletBudgetData = {}
  ) {
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    let yPosition = 20;

    // Set watermark with ELRA branding (like payslips)
    doc.setGState(new doc.GState({ opacity: 0.05 }));
    doc.setTextColor(100, 100, 100);
    doc.setFontSize(100);
    doc.text("ELRA", pageWidth / 2, pageHeight / 2, {
      align: "center",
      angle: 30,
      renderingMode: "fill",
    });

    // Reset opacity for rest of the content
    doc.setGState(new doc.GState({ opacity: 1 }));

    // Header with ELRA branding (matching payslip style)
    const elraGreen = [13, 100, 73];
    doc.setTextColor(elraGreen[0], elraGreen[1], elraGreen[2]);
    doc.setFontSize(32);
    doc.setFont("helvetica", "bold");
    doc.text("ELRA", pageWidth / 2, 25, { align: "center" });

    // Reset to black for subtitle
    doc.setTextColor(0, 0, 0);
    doc.setFontSize(16);
    doc.setFont("helvetica", "normal");
    doc.text("Wallet Transaction Report", pageWidth / 2, 35, {
      align: "center",
    });

    yPosition = 50;

    // Report metadata
    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");
    doc.text(
      `Generated on: ${new Date().toLocaleDateString("en-NG")}`,
      20,
      yPosition
    );
    doc.text(
      `Generated by: ${userInfo.name || "System"}`,
      pageWidth - 20,
      yPosition,
      { align: "right" }
    );
    yPosition += 8;

    doc.text(`Department: ${userInfo.department || "N/A"}`, 20, yPosition);
    doc.text(`Role: ${userInfo.role || "N/A"}`, pageWidth - 20, yPosition, {
      align: "right",
    });
    yPosition += 15;

    // Filters applied
    if (Object.keys(filters).length > 0) {
      doc.setFontSize(12);
      doc.setFont("helvetica", "bold");
      doc.text("Filters Applied:", 20, yPosition);
      yPosition += 8;

      doc.setFontSize(10);
      doc.setFont("helvetica", "normal");

      if (filters.type) {
        doc.text(`• Transaction Type: ${filters.type}`, 25, yPosition);
        yPosition += 5;
      }
      if (filters.startDate) {
        doc.text(
          `• Start Date: ${new Date(filters.startDate).toLocaleDateString(
            "en-NG"
          )}`,
          25,
          yPosition
        );
        yPosition += 5;
      }
      if (filters.endDate) {
        doc.text(
          `• End Date: ${new Date(filters.endDate).toLocaleDateString(
            "en-NG"
          )}`,
          25,
          yPosition
        );
        yPosition += 5;
      }
      yPosition += 10;
    }

    // Summary statistics
    const totalTransactions = transactions.length;
    const totalDeposits = transactions
      .filter((t) => t.type === "deposit")
      .reduce((sum, t) => sum + t.amount, 0);
    const totalWithdrawals = transactions
      .filter((t) => t.type === "withdrawal")
      .reduce((sum, t) => sum + t.amount, 0);
    const currentBalance =
      transactions.length > 0 ? transactions[0].balanceAfter : 0;

    doc.setFontSize(12);
    doc.setFont("helvetica", "bold");
    doc.text("Summary Statistics:", 20, yPosition);
    yPosition += 8;

    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");
    doc.text(`• Total Transactions: ${totalTransactions}`, 25, yPosition);
    yPosition += 5;
    doc.text(
      `• Total Deposits: NGN ${this.formatCurrency(totalDeposits)}`,
      25,
      yPosition
    );
    yPosition += 5;
    doc.text(
      `• Total Withdrawals: NGN ${this.formatCurrency(totalWithdrawals)}`,
      25,
      yPosition
    );
    yPosition += 5;
    doc.text(
      `• Current Balance: NGN ${this.formatCurrency(currentBalance)}`,
      25,
      yPosition
    );
    yPosition += 15;

    // Budget Allocation & Utilization Summary
    this.addBudgetAllocationSection(
      doc,
      transactions,
      yPosition,
      walletBudgetData
    );
    yPosition = this.getCurrentYPosition(doc);

    // Transaction table
    if (transactions.length > 0) {
      doc.setFontSize(12);
      doc.setFont("helvetica", "bold");
      doc.text("Transaction Details:", 20, yPosition);
      yPosition += 10;

      const tableData = transactions.map((transaction) => [
        new Date(transaction.date).toLocaleDateString("en-NG"),
        new Date(transaction.date).toLocaleTimeString("en-NG"),
        transaction.type.toUpperCase(),
        this.truncateText(
          (transaction.description || "N/A")
            .replace(/_/g, " ")
            .replace(/-/g, " "),
          30
        ),
        this.truncateText(transaction.reference || "N/A", 20),
        this.formatTransactionAmount(transaction),
        `NGN ${this.formatCurrency(transaction.balanceAfter)}`,
      ]);

      autoTable(doc, {
        head: [
          [
            "Date",
            "Time",
            "Type",
            "Description",
            "Reference",
            "Amount",
            "Balance",
          ],
        ],
        body: tableData,
        startY: yPosition,
        styles: {
          fontSize: 8,
          cellPadding: 3,
        },
        headStyles: {
          fillColor: [13, 100, 73], // ELRA green color (matching payslips)
          textColor: 255,
          fontStyle: "bold",
        },
        alternateRowStyles: {
          fillColor: [245, 245, 245],
        },
        columnStyles: {
          0: { cellWidth: 20 }, // Date
          1: { cellWidth: 15 }, // Time
          2: { cellWidth: 20 }, // Type
          3: { cellWidth: 40 }, // Description
          4: { cellWidth: 25 }, // Reference
          5: { cellWidth: 25 }, // Amount
          6: { cellWidth: 25 }, // Balance
        },
        margin: { left: 20, right: 20 },
      });

      yPosition = doc.lastAutoTable.finalY + 10;
    } else {
      doc.setFontSize(12);
      doc.setFont("helvetica", "italic");
      doc.text(
        "No transactions found for the specified criteria.",
        20,
        yPosition
      );
      yPosition += 10;
    }

    // Footer
    const footerY = pageHeight - 20;
    doc.setFontSize(8);
    doc.setFont("helvetica", "normal");
    doc.text(
      "This report was generated by ELRA ERP System",
      pageWidth / 2,
      footerY,
      { align: "center" }
    );

    // Add page numbers only once
    const pageCount = doc.internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.text(`Page ${i} of ${pageCount}`, pageWidth - 20, pageHeight - 10, {
        align: "right",
      });
    }
  }

  /**
   * Format currency for display
   */
  formatCurrency(amount) {
    return new Intl.NumberFormat("en-NG", {
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(amount || 0);
  }

  /**
   * Format transaction amount with proper signs
   */
  formatTransactionAmount(transaction) {
    const amount = Math.abs(transaction.amount);
    const formattedAmount = this.formatCurrency(amount);

    switch (transaction.type) {
      case "deposit":
        return `+NGN ${formattedAmount}`;
      case "withdrawal":
        return `-NGN ${formattedAmount}`;
      case "allocation":
        return `NGN ${formattedAmount}`;
      default:
        return `NGN ${formattedAmount}`;
    }
  }

  /**
   * Truncate text to specified length
   */
  truncateText(text, maxLength) {
    if (!text || text.length <= maxLength) {
      return text;
    }
    return text.substring(0, maxLength - 3) + "...";
  }

  /**
   * Generate Word document report (using HTML to DOCX conversion)
   */
  async generateTransactionWordReport(
    transactions,
    filters = {},
    userInfo = {}
  ) {
    try {
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
      const fileName = `transaction_report_${timestamp}.html`;
      const filePath = path.join(this.reportsDir, fileName);

      // Get the actual wallet data for accurate budget allocation
      const wallet = await ELRAWallet.findOne({ elraInstance: "ELRA_MAIN" });
      const walletBudgetData = wallet?.budgetCategories || {};

      const htmlContent = this.generateWordReportHTML(
        transactions,
        filters,
        userInfo,
        walletBudgetData
      );
      fs.writeFileSync(filePath, htmlContent);

      return {
        fileName,
        filePath,
        url: `/uploads/transaction-reports/${fileName}`,
        htmlContent,
      };
    } catch (error) {
      console.error(
        "❌ [TRANSACTION REPORT SERVICE] Error generating Word report:",
        error
      );
      throw error;
    }
  }

  /**
   * Generate HTML content for Word export
   */
  generateWordReportHTML(
    transactions,
    filters,
    userInfo,
    walletBudgetData = {}
  ) {
    const totalTransactions = transactions.length;
    const totalDeposits = transactions
      .filter((t) => t.type === "deposit")
      .reduce((sum, t) => sum + t.amount, 0);
    const totalWithdrawals = transactions
      .filter((t) => t.type === "withdrawal")
      .reduce((sum, t) => sum + t.amount, 0);
    const currentBalance =
      transactions.length > 0 ? transactions[0].balanceAfter : 0;

    return `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ELRA Wallet Transaction Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .header { text-align: center; margin-bottom: 30px; }
        .header h1 { color: #0d6449; font-size: 24px; margin-bottom: 10px; }
        .metadata { margin-bottom: 20px; font-size: 12px; color: #666; }
        .summary { background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .summary h3 { color: #0d6449; margin-bottom: 10px; }
        .filters { background-color: #fff3cd; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .filters h3 { color: #856404; margin-bottom: 10px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #0d6449; color: white; font-weight: bold; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        .amount-positive { color: #27ae60; font-weight: bold; }
        .amount-negative { color: #e74c3c; font-weight: bold; }
        .footer { margin-top: 30px; text-align: center; font-size: 10px; color: #666; }
    </style>
</head>
<body>
    <div class="header">
        <h1>ELRA Wallet Transaction Report</h1>
        <div class="metadata">
            <p><strong>Generated on:</strong> ${new Date().toLocaleDateString(
              "en-NG"
            )}</p>
            <p><strong>Generated by:</strong> ${userInfo.name || "System"}</p>
            <p><strong>Department:</strong> ${userInfo.department || "N/A"}</p>
            <p><strong>Role:</strong> ${userInfo.role || "N/A"}</p>
        </div>
    </div>

    ${
      Object.keys(filters).length > 0
        ? `
    <div class="filters">
        <h3>Filters Applied:</h3>
        <ul>
            ${
              filters.type
                ? `<li><strong>Transaction Type:</strong> ${filters.type}</li>`
                : ""
            }
            ${
              filters.startDate
                ? `<li><strong>Start Date:</strong> ${new Date(
                    filters.startDate
                  ).toLocaleDateString("en-NG")}</li>`
                : ""
            }
            ${
              filters.endDate
                ? `<li><strong>End Date:</strong> ${new Date(
                    filters.endDate
                  ).toLocaleDateString("en-NG")}</li>`
                : ""
            }
        </ul>
    </div>
    `
        : ""
    }

    <div class="summary">
        <h3>Summary Statistics:</h3>
        <ul>
            <li><strong>Total Transactions:</strong> ${totalTransactions}</li>
            <li><strong>Total Deposits:</strong> NGN ${this.formatCurrency(
              totalDeposits
            )}</li>
            <li><strong>Total Withdrawals:</strong> NGN ${this.formatCurrency(
              totalWithdrawals
            )}</li>
            <li><strong>Current Balance:</strong> NGN ${this.formatCurrency(
              currentBalance
            )}</li>
        </ul>
    </div>

    ${this.generateBudgetAllocationHTML(walletBudgetData)}

    <h3>Transaction Details:</h3>
    ${
      transactions.length > 0
        ? `
    <table>
        <thead>
            <tr>
                <th>Date</th>
                <th>Time</th>
                <th>Type</th>
                <th>Description</th>
                <th>Reference</th>
                <th>Amount</th>
                <th>Balance</th>
            </tr>
        </thead>
        <tbody>
            ${transactions
              .map(
                (transaction) => `
                <tr>
                    <td>${new Date(transaction.date).toLocaleDateString(
                      "en-NG"
                    )}</td>
                    <td>${new Date(transaction.date).toLocaleTimeString(
                      "en-NG"
                    )}</td>
                    <td>${transaction.type.toUpperCase()}</td>
                    <td>${(transaction.description || "N/A")
                      .replace(/_/g, " ")
                      .replace(/-/g, " ")}</td>
                    <td>${transaction.reference || "N/A"}</td>
                    <td class="${
                      transaction.type === "deposit"
                        ? "amount-positive"
                        : transaction.type === "withdrawal"
                        ? "amount-negative"
                        : ""
                    }">
                        ${this.formatTransactionAmount(transaction)}
                    </td>
                    <td>NGN ${this.formatCurrency(
                      transaction.balanceAfter
                    )}</td>
                </tr>
            `
              )
              .join("")}
        </tbody>
    </table>
    `
        : "<p><em>No transactions found for the specified criteria.</em></p>"
    }

    <div class="footer">
        <p>This report was generated by ELRA ERP System</p>
        <p>Generated on ${new Date().toLocaleString("en-NG")}</p>
    </div>
</body>
</html>
    `;
  }

  /**
   * Generate CSV report
   */
  async generateTransactionCSVReport(
    transactions,
    filters = {},
    userInfo = {}
  ) {
    try {
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
      const fileName = `transaction_report_${timestamp}.csv`;
      const filePath = path.join(this.reportsDir, fileName);

      // Get the actual wallet data for accurate budget allocation
      const wallet = await ELRAWallet.findOne({ elraInstance: "ELRA_MAIN" });
      const walletBudgetData = wallet?.budgetCategories || {};

      const csvContent = this.generateCSVContent(
        transactions,
        filters,
        userInfo,
        walletBudgetData
      );
      fs.writeFileSync(filePath, csvContent);

      return {
        fileName,
        filePath,
        url: `/uploads/transaction-reports/${fileName}`,
        csvContent,
      };
    } catch (error) {
      console.error(
        "❌ [TRANSACTION REPORT SERVICE] Error generating CSV report:",
        error
      );
      throw error;
    }
  }

  /**
   * Generate CSV content
   */
  generateCSVContent(transactions, filters, userInfo, walletBudgetData = {}) {
    const headers = [
      "Date",
      "Time",
      "Type",
      "Description",
      "Reference",
      "Amount",
      "Balance",
    ];

    const rows = transactions.map((transaction) => [
      new Date(transaction.date).toLocaleDateString("en-NG"),
      new Date(transaction.date).toLocaleTimeString("en-NG"),
      transaction.type.toUpperCase(),
      `"${(transaction.description || "N/A")
        .replace(/_/g, " ")
        .replace(/-/g, " ")}"`,
      transaction.reference || "N/A",
      this.formatTransactionAmount(transaction),
      `NGN ${this.formatCurrency(transaction.balanceAfter)}`,
    ]);

    // Add budget allocation summary using actual wallet data
    const budgetData = this.getWalletBudgetData(walletBudgetData);
    const summaryRows = [
      [],
      ["BUDGET ALLOCATION & UTILIZATION SUMMARY"],
      [],
      ["Category", "Allocated", "Used", "Available", "Utilization %"],
      [
        "Payroll",
        budgetData.payroll.allocated,
        budgetData.payroll.used,
        budgetData.payroll.available,
        budgetData.payroll.allocated > 0
          ? (
              (budgetData.payroll.used / budgetData.payroll.allocated) *
              100
            ).toFixed(1)
          : 0,
      ],
      [
        "Operational",
        budgetData.operational.allocated,
        budgetData.operational.used,
        budgetData.operational.available,
        budgetData.operational.allocated > 0
          ? (
              (budgetData.operational.used / budgetData.operational.allocated) *
              100
            ).toFixed(1)
          : 0,
      ],
      [
        "Projects",
        budgetData.projects.allocated,
        budgetData.projects.used,
        budgetData.projects.available,
        budgetData.projects.allocated > 0
          ? (
              (budgetData.projects.used / budgetData.projects.allocated) *
              100
            ).toFixed(1)
          : 0,
      ],
      [
        "TOTAL",
        budgetData.total.allocated,
        budgetData.total.used,
        budgetData.total.available,
        budgetData.total.allocated > 0
          ? (
              (budgetData.total.used / budgetData.total.allocated) *
              100
            ).toFixed(1)
          : 0,
      ],
      [],
      ["FUND FLOW SUMMARY"],
      [],
      ["Metric", "Amount"],
      [
        "Total Funds Added",
        transactions
          .filter((t) => t.type === "deposit")
          .reduce((sum, t) => sum + t.amount, 0),
      ],
      [
        "Total Allocations",
        transactions
          .filter((t) => t.type === "allocation")
          .reduce((sum, t) => sum + t.amount, 0),
      ],
      [
        "Total Withdrawals",
        transactions
          .filter((t) => t.type === "withdrawal")
          .reduce((sum, t) => sum + t.amount, 0),
      ],
      [
        "Flow Efficiency %",
        transactions
          .filter((t) => t.type === "deposit")
          .reduce((sum, t) => sum + t.amount, 0) > 0
          ? (
              (transactions
                .filter(
                  (t) => t.type === "withdrawal" && t.status === "approved"
                )
                .reduce((sum, t) => sum + t.amount, 0) /
                transactions
                  .filter((t) => t.type === "deposit")
                  .reduce((sum, t) => sum + t.amount, 0)) *
              100
            ).toFixed(1)
          : 0,
      ],
    ];

    const csvRows = [headers, ...rows, ...summaryRows];
    return csvRows.map((row) => row.join(",")).join("\n");
  }

  /**
   * Add budget allocation and utilization section to the report
   */
  addBudgetAllocationSection(
    doc,
    transactions,
    yPosition,
    walletBudgetData = {}
  ) {
    const pageWidth = doc.internal.pageSize.getWidth();

    // Use actual wallet budget data instead of calculating from transactions
    const budgetData = this.getWalletBudgetData(walletBudgetData);

    // Section header
    doc.setFontSize(12);
    doc.setFont("helvetica", "bold");
    doc.text("Budget Allocation & Utilization:", 20, yPosition);
    yPosition += 8;

    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");

    // Budget categories summary
    const categories = ["payroll", "operational", "projects"];
    categories.forEach((category) => {
      const data = budgetData[category];
      if (data.allocated > 0) {
        const utilization =
          data.allocated > 0
            ? ((data.used / data.allocated) * 100).toFixed(1)
            : 0;

        doc.text(
          `${category.charAt(0).toUpperCase() + category.slice(1)} Budget:`,
          25,
          yPosition
        );
        doc.text(
          `Allocated: NGN ${this.formatCurrency(data.allocated)}`,
          80,
          yPosition
        );
        doc.text(`Used: NGN ${this.formatCurrency(data.used)}`, 130, yPosition);
        doc.text(`Utilization: ${utilization}%`, 170, yPosition);
        yPosition += 5;
      }
    });

    yPosition += 5;

    // Overall utilization
    const totalAllocated = budgetData.total.allocated;
    const totalUsed = budgetData.total.used;
    const overallUtilization =
      totalAllocated > 0 ? ((totalUsed / totalAllocated) * 100).toFixed(1) : 0;

    doc.setFont("helvetica", "bold");
    doc.text(
      `Overall Budget Utilization: ${overallUtilization}%`,
      25,
      yPosition
    );
    yPosition += 8;

    // Fund flow summary
    doc.setFont("helvetica", "normal");
    doc.text("Fund Flow Summary:", 25, yPosition);
    yPosition += 5;

    const totalDeposits = transactions
      .filter((t) => t.type === "deposit")
      .reduce((sum, t) => sum + t.amount, 0);
    const totalWithdrawals = transactions
      .filter((t) => t.type === "withdrawal")
      .reduce((sum, t) => sum + t.amount, 0);
    const totalAllocations = transactions
      .filter((t) => t.type === "allocation")
      .reduce((sum, t) => sum + t.amount, 0);

    doc.text(
      `• Total Funds Added: NGN ${this.formatCurrency(totalDeposits)}`,
      30,
      yPosition
    );
    yPosition += 5;
    doc.text(
      `• Total Allocations: NGN ${this.formatCurrency(totalAllocations)}`,
      30,
      yPosition
    );
    yPosition += 5;
    doc.text(
      `• Total Withdrawals: NGN ${this.formatCurrency(totalWithdrawals)}`,
      30,
      yPosition
    );
    yPosition += 5;

    // Calculate flow efficiency using only approved withdrawals (same logic as app page)
    const approvedWithdrawals = transactions
      .filter((t) => t.type === "withdrawal" && t.status === "approved")
      .reduce((sum, t) => sum + t.amount, 0);

    const flowEfficiency =
      totalDeposits > 0
        ? ((approvedWithdrawals / totalDeposits) * 100).toFixed(1)
        : 0;
    doc.text(`• Flow Efficiency: ${flowEfficiency}%`, 30, yPosition);
    yPosition += 10;

    // Store current Y position for the calling method
    this.currentYPosition = yPosition;
  }

  /**
   * Calculate budget allocation data from transactions
   */
  calculateBudgetAllocation(transactions) {
    const budgetData = {
      payroll: { allocated: 0, used: 0, available: 0 },
      operational: { allocated: 0, used: 0, available: 0 },
      projects: { allocated: 0, used: 0, available: 0 },
      total: { allocated: 0, used: 0, available: 0 },
    };

    transactions.forEach((transaction) => {
      const category = transaction.budgetCategory;
      if (category && budgetData[category]) {
        if (transaction.type === "allocation") {
          budgetData[category].allocated += transaction.amount;
          budgetData.total.allocated += transaction.amount;
        } else if (
          transaction.type === "withdrawal" &&
          transaction.status === "approved"
        ) {
          budgetData[category].used += transaction.amount;
          budgetData.total.used += transaction.amount;
        }
      }
    });

    // Calculate available amounts
    Object.keys(budgetData).forEach((key) => {
      if (key !== "total") {
        budgetData[key].available =
          budgetData[key].allocated - budgetData[key].used;
      }
    });
    budgetData.total.available =
      budgetData.total.allocated - budgetData.total.used;

    return budgetData;
  }

  /**
   * Get current Y position for layout management
   */
  getCurrentYPosition(doc) {
    return this.currentYPosition || 0;
  }

  /**
   * Get wallet budget data in the correct format
   */
  getWalletBudgetData(walletBudgetData) {
    const budgetData = {
      payroll: { allocated: 0, used: 0, available: 0 },
      operational: { allocated: 0, used: 0, available: 0 },
      projects: { allocated: 0, used: 0, available: 0 },
      total: { allocated: 0, used: 0, available: 0 },
    };

    // Map wallet budget data to our format
    if (walletBudgetData.payroll) {
      budgetData.payroll = {
        allocated: walletBudgetData.payroll.allocated || 0,
        used: walletBudgetData.payroll.used || 0,
        available: walletBudgetData.payroll.available || 0,
      };
    }

    if (walletBudgetData.operational) {
      budgetData.operational = {
        allocated: walletBudgetData.operational.allocated || 0,
        used: walletBudgetData.operational.used || 0,
        available: walletBudgetData.operational.available || 0,
      };
    }

    if (walletBudgetData.projects) {
      budgetData.projects = {
        allocated: walletBudgetData.projects.allocated || 0,
        used: walletBudgetData.projects.used || 0,
        available: walletBudgetData.projects.available || 0,
      };
    }

    // Calculate totals
    budgetData.total.allocated =
      budgetData.payroll.allocated +
      budgetData.operational.allocated +
      budgetData.projects.allocated;
    budgetData.total.used =
      budgetData.payroll.used +
      budgetData.operational.used +
      budgetData.projects.used;
    budgetData.total.available =
      budgetData.total.allocated - budgetData.total.used;

    return budgetData;
  }

  /**
   * Generate budget allocation HTML section for Word export
   */
  generateBudgetAllocationHTML(walletBudgetData) {
    const budgetData = this.getWalletBudgetData(walletBudgetData);

    const categories = ["payroll", "operational", "projects"];
    let categoryRows = "";

    categories.forEach((category) => {
      const data = budgetData[category];
      if (data.allocated > 0) {
        const utilization =
          data.allocated > 0
            ? ((data.used / data.allocated) * 100).toFixed(1)
            : 0;
        categoryRows += `
            <tr>
                <td>${category.charAt(0).toUpperCase() + category.slice(1)}</td>
                <td>NGN ${this.formatCurrency(data.allocated)}</td>
                <td>NGN ${this.formatCurrency(data.used)}</td>
                <td>NGN ${this.formatCurrency(data.available)}</td>
                <td>${utilization}%</td>
            </tr>`;
      }
    });

    const totalAllocated = budgetData.total.allocated;
    const totalUsed = budgetData.total.used;
    const overallUtilization =
      totalAllocated > 0 ? ((totalUsed / totalAllocated) * 100).toFixed(1) : 0;

    return `
    <div class="summary">
        <h3>Budget Allocation & Utilization:</h3>
        <table>
            <thead>
                <tr>
                    <th>Category</th>
                    <th>Allocated</th>
                    <th>Used</th>
                    <th>Available</th>
                    <th>Utilization %</th>
                </tr>
            </thead>
            <tbody>
                ${categoryRows}
                <tr style="font-weight: bold; background-color: #e8f5e8;">
                    <td>TOTAL</td>
                    <td>NGN ${this.formatCurrency(totalAllocated)}</td>
                    <td>NGN ${this.formatCurrency(totalUsed)}</td>
                    <td>NGN ${this.formatCurrency(
                      budgetData.total.available
                    )}</td>
                    <td>${overallUtilization}%</td>
                </tr>
            </tbody>
        </table>
        <p style="margin-top: 10px;"><strong>Overall Budget Utilization:</strong> ${overallUtilization}%</p>
    </div>`;
  }
}

export default TransactionReportService;
