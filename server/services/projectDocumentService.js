import Document from "../models/Document.js";
import Project from "../models/Project.js";
import User from "../models/User.js";
import Department from "../models/Department.js";

class ProjectDocumentService {
  /**
   * Auto-create required documents for a project based on category and budget
   */
  static async createProjectDocuments(project, createdBy) {
    try {
      console.log(
        "📄 [DOCUMENTS] Creating required documents for project:",
        project.code
      );

      const requiredDocuments = this.getRequiredDocumentsByCategory(
        project.category,
        project.budget
      );
      const createdDocuments = [];

      for (const docConfig of requiredDocuments) {
        try {
          const document = new Document({
            title: `${docConfig.title} - ${project.name}`,
            description: `${docConfig.description} for project ${project.code}`,
            fileName: `${project.code}_${docConfig.type}_template.pdf`,
            originalFileName: `${project.code}_${docConfig.type}_template.pdf`,
            fileUrl: `/templates/${docConfig.type}_template.pdf`,
            fileSize: 0,
            mimeType: "application/pdf",
            documentType: docConfig.type,
            category: docConfig.category,
            status: "draft",
            project: project._id,
            department: project.department,
            createdBy: createdBy._id,
            tags: [project.category, docConfig.type, "auto-generated"],
            metadata: {
              projectCode: project.code,
              projectCategory: project.category,
              budget: project.budget.toString(),
              autoGenerated: "true",
              requiredDocument: "true",
            },
          });

          await document.save();
          createdDocuments.push(document);

          console.log(
            `📄 [DOCUMENTS] Created: ${docConfig.title} for project ${project.code}`
          );
        } catch (error) {
          console.error(
            `❌ [DOCUMENTS] Error creating ${docConfig.title}:`,
            error
          );
        }
      }

      console.log(
        `✅ [DOCUMENTS] Created ${createdDocuments.length} documents for project ${project.code}`
      );
      return createdDocuments;
    } catch (error) {
      console.error("❌ [DOCUMENTS] Error creating project documents:", error);
      throw error;
    }
  }

  /**
   * Get required documents based on project category and budget
   */
  static getRequiredDocumentsByCategory(category, budget) {
    const baseDocuments = [
      {
        type: "project_proposal",
        title: "Project Proposal",
        description: "Detailed project proposal document",
        category: "project",
        required: true,
      },
      {
        type: "budget_breakdown",
        title: "Budget Breakdown",
        description: "Detailed budget allocation and justification",
        category: "financial",
        required: true,
      },
    ];

    // Category-specific documents
    const categoryDocuments = {
      equipment_lease: [
        {
          type: "technical_specifications",
          title: "Equipment Specifications",
          description: "Technical specifications for equipment to be leased",
          category: "technical",
          required: true,
        },
        {
          type: "vendor_quotes",
          title: "Vendor Quotes",
          description: "Quotes from potential equipment vendors",
          category: "financial",
          required: true,
        },
      ],
      vehicle_lease: [
        {
          type: "technical_specifications",
          title: "Vehicle Specifications",
          description: "Technical specifications for vehicles to be leased",
          category: "technical",
          required: true,
        },
        {
          type: "legal_review",
          title: "Legal Review",
          description: "Legal review of vehicle lease agreements",
          category: "legal",
          required: true,
        },
      ],
      software_development: [
        {
          type: "technical_specifications",
          title: "Software Requirements",
          description: "Detailed software requirements and specifications",
          category: "technical",
          required: true,
        },
        {
          type: "timeline_detailed",
          title: "Development Timeline",
          description: "Detailed software development timeline",
          category: "project",
          required: true,
        },
      ],
      financial_lease: [
        {
          type: "financial_analysis",
          title: "Financial Analysis",
          description: "Detailed financial analysis and projections",
          category: "financial",
          required: true,
        },
        {
          type: "legal_review",
          title: "Legal Review",
          description: "Legal review of financial lease agreements",
          category: "legal",
          required: true,
        },
      ],
    };

    // Budget-based documents
    const budgetDocuments = [];
    if (budget > 5000000) {
      // > 5M NGN
      budgetDocuments.push({
        type: "financial_analysis",
        title: "Financial Analysis",
        description: "Comprehensive financial analysis for high-budget project",
        category: "financial",
        required: true,
      });
    }

    if (budget > 10000000) {
      // > 10M NGN
      budgetDocuments.push({
        type: "risk_assessment",
        title: "Risk Assessment",
        description: "Comprehensive risk assessment for high-value project",
        category: "project",
        required: true,
      });
    }

    if (budget > 25000000) {
      // > 25M NGN
      budgetDocuments.push({
        type: "legal_review",
        title: "Legal Review",
        description: "Legal review required for high-value project",
        category: "legal",
        required: true,
      });
    }

    // Combine all documents
    const allDocuments = [
      ...baseDocuments,
      ...(categoryDocuments[category] || []),
      ...budgetDocuments,
    ];

    // Remove duplicates based on type
    const uniqueDocuments = allDocuments.filter(
      (doc, index, self) => index === self.findIndex((d) => d.type === doc.type)
    );

    return uniqueDocuments;
  }

  /**
   * Create document approval workflow for regulatory compliance
   */
  static async createDocumentApprovalWorkflow(document, project) {
    try {
      console.log(
        "📋 [DOCUMENT WORKFLOW] Creating approval workflow for:",
        document.title
      );

      const approvalChain = await this.generateDocumentApprovalChain(
        document,
        project
      );

      // Update document with approval chain
      document.reviewers = approvalChain.map((approver) => ({
        reviewer: approver.userId,
        status: "pending",
        required: approver.required,
        comments: "",
      }));

      document.reviewStatus = "pending";
      await document.save();

      console.log(
        `✅ [DOCUMENT WORKFLOW] Created approval workflow with ${approvalChain.length} reviewers`
      );
      return approvalChain;
    } catch (error) {
      console.error(
        "❌ [DOCUMENT WORKFLOW] Error creating approval workflow:",
        error
      );
      throw error;
    }
  }

  /**
   * Generate approval chain for documents based on type and project
   */
  static async generateDocumentApprovalChain(document, project) {
    const approvalChain = [];

    // Base approval - Project Manager
    if (project.projectManager) {
      approvalChain.push({
        userId: project.projectManager,
        role: "project_manager",
        level: 1,
        required: true,
        department: project.department,
      });
    }

    // Category-based approvals
    switch (document.category) {
      case "financial":
        // Finance department approval for financial documents
        const financeDept = await Department.findOne({
          name: "Finance & Accounting",
        });
        if (financeDept) {
          const financeHOD = await User.findOne({
            "role.name": "HOD",
            department: financeDept._id,
          });
          if (financeHOD) {
            approvalChain.push({
              userId: financeHOD._id,
              role: "finance_hod",
              level: 2,
              required: true,
              department: financeDept._id,
            });
          }
        }
        break;

      case "legal":
        // Legal department approval for legal documents
        const legalDept = await Department.findOne({
          name: "Legal & Compliance",
        });
        if (legalDept) {
          const legalHOD = await User.findOne({
            "role.name": "HOD",
            department: legalDept._id,
          });
          if (legalHOD) {
            approvalChain.push({
              userId: legalHOD._id,
              role: "legal_hod",
              level: 2,
              required: true,
              department: legalDept._id,
            });
          }
        }
        break;

      case "technical":
        // Technical review by IT department
        const itDept = await Department.findOne({
          name: "Information Technology",
        });
        if (itDept) {
          const itHOD = await User.findOne({
            "role.name": "HOD",
            department: itDept._id,
          });
          if (itHOD) {
            approvalChain.push({
              userId: itHOD._id,
              role: "technical_hod",
              level: 2,
              required: true,
              department: itDept._id,
            });
          }
        }
        break;
    }

    // Budget-based approvals
    if (project.budget > 25000000) {
      // > 25M NGN
      // Executive approval for high-value projects
      const execDept = await Department.findOne({ name: "Executive Office" });
      if (execDept) {
        const execHOD = await User.findOne({
          "role.name": "HOD",
          department: execDept._id,
        });
        if (execHOD) {
          approvalChain.push({
            userId: execHOD._id,
            role: "executive_hod",
            level: 3,
            required: true,
            department: execDept._id,
          });
        }
      }
    }

    return approvalChain;
  }

  /**
   * Approve a document
   */
  static async approveDocument(documentId, reviewerId, comments = "") {
    try {
      const document = await Document.findById(documentId);
      if (!document) {
        throw new Error("Document not found");
      }

      // Find the reviewer in the approval chain
      const reviewer = document.reviewers.find(
        (r) => r.reviewer.toString() === reviewerId.toString()
      );
      if (!reviewer) {
        throw new Error("Reviewer not found in approval chain");
      }

      // Update reviewer status
      reviewer.status = "approved";
      reviewer.comments = comments;
      reviewer.reviewedAt = new Date();

      // Check if all required reviewers have approved
      const allRequiredApproved = document.reviewers
        .filter((r) => r.required)
        .every((r) => r.status === "approved");

      if (allRequiredApproved) {
        document.reviewStatus = "approved";
        document.status = "approved";
      } else {
        document.reviewStatus = "in_review";
      }

      await document.save();

      console.log(
        `✅ [DOCUMENT] Document ${document.title} approved by reviewer`
      );
      return document;
    } catch (error) {
      console.error("❌ [DOCUMENT] Error approving document:", error);
      throw error;
    }
  }

  /**
   * Reject a document
   */
  static async rejectDocument(documentId, reviewerId, comments = "") {
    try {
      const document = await Document.findById(documentId);
      if (!document) {
        throw new Error("Document not found");
      }

      // Find the reviewer in the approval chain
      const reviewer = document.reviewers.find(
        (r) => r.reviewer.toString() === reviewerId.toString()
      );
      if (!reviewer) {
        throw new Error("Reviewer not found in approval chain");
      }

      // Update reviewer status
      reviewer.status = "rejected";
      reviewer.comments = comments;
      reviewer.reviewedAt = new Date();

      // If any required reviewer rejects, document is rejected
      document.reviewStatus = "rejected";
      document.status = "rejected";

      await document.save();

      console.log(
        `❌ [DOCUMENT] Document ${document.title} rejected by reviewer`
      );
      return document;
    } catch (error) {
      console.error("❌ [DOCUMENT] Error rejecting document:", error);
      throw error;
    }
  }

  /**
   * Get project documents with approval status
   */
  static async getProjectDocuments(projectId) {
    try {
      const documents = await Document.find({
        project: projectId,
        isActive: true,
      })
        .populate("createdBy", "firstName lastName email")
        .populate(
          "reviewers.reviewer",
          "firstName lastName email role department"
        )
        .populate("approvedBy", "firstName lastName email")
        .sort({ createdAt: -1 });

      return documents;
    } catch (error) {
      console.error("❌ [DOCUMENT] Error getting project documents:", error);
      throw error;
    }
  }

  /**
   * Get documents pending approval for a user
   */
  static async getPendingApprovalDocuments(userId) {
    try {
      const documents = await Document.find({
        "reviewers.reviewer": userId,
        "reviewers.status": "pending",
        isActive: true,
      })
        .populate("project", "name code category budget")
        .populate("createdBy", "firstName lastName email")
        .populate("department", "name")
        .sort({ createdAt: -1 });

      return documents;
    } catch (error) {
      console.error(
        "❌ [DOCUMENT] Error getting pending approval documents:",
        error
      );
      throw error;
    }
  }
}

export default ProjectDocumentService;
