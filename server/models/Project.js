import mongoose from "mongoose";
import ProjectAuditService from "../services/projectAuditService.js";
import ProjectDocumentService from "../services/projectDocumentService.js";
import WorkflowTemplateService from "../services/workflowTemplateService.js";

const projectSchema = new mongoose.Schema(
  {
    // Basic Project Information
    name: {
      type: String,
      required: true,
      trim: true,
      maxlength: 200,
    },
    description: {
      type: String,
      required: true,
      trim: true,
      maxlength: 1000,
    },
    code: {
      type: String,
      unique: true,
      trim: true,
      uppercase: true,
      maxlength: 20,
    },

    // Project Status and Priority
    status: {
      type: String,
      enum: [
        "planning",
        "pending_approval",
        "pending_department_approval",
        "pending_finance_approval",
        "pending_executive_approval",
        "approved",
        "implementation",
        "active",
        "on_hold",
        "completed",
        "cancelled",
        "rejected",
      ],
      default: "planning",
      required: true,
    },
    priority: {
      type: String,
      enum: ["low", "medium", "high", "critical"],
      default: "medium",
      required: true,
    },

    // Project Timeline
    startDate: {
      type: Date,
      required: true,
    },
    endDate: {
      type: Date,
      required: true,
    },
    actualStartDate: {
      type: Date,
    },
    actualEndDate: {
      type: Date,
    },

    // Project Budget (in Naira)
    budget: {
      type: Number,
      required: true,
      min: 0,
    },
    actualCost: {
      type: Number,
      default: 0,
      min: 0,
    },

    // Budget Approval Thresholds
    budgetThreshold: {
      type: String,
      enum: [
        "hod_auto_approve",
        "department_approval",
        "finance_approval",
        "executive_approval",
      ],
      default: "hod_auto_approve",
    },

    // Project Team
    projectManager: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    teamName: {
      type: String,
      trim: true,
      maxlength: 100,
      default: function () {
        return this.name ? `${this.name} Team` : "Project Team";
      },
    },
    teamMembers: [
      {
        user: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "User",
          required: true,
        },
        role: {
          type: String,
          required: true,
          enum: [
            "developer",
            "designer",
            "analyst",
            "tester",
            "consultant",
            "manager",
            "coordinator",
            "other",
          ],
        },
        assignedDate: {
          type: Date,
          default: Date.now,
        },
        isActive: {
          type: Boolean,
          default: true,
        },
      },
    ],

    // Project Department (which department owns this project)
    department: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Department",
      required: true,
    },

    // Project Categories (relevant for leasing business)
    category: {
      type: String,
      required: true,
      enum: [
        "equipment_lease",
        "vehicle_lease",
        "property_lease",
        "financial_lease",
        "training_equipment_lease",
        "compliance_lease",
        "service_equipment_lease",
        "strategic_lease",
        "software_development",
        "system_maintenance",
        "consulting",
        "training",
        "other",
      ],
    },
    customCategory: {
      type: String,
      trim: true,
      maxlength: 100,
    },

    // Project Progress
    progress: {
      type: Number,
      min: 0,
      max: 100,
      default: 0,
    },

    // Workflow Tracking Fields (Phase 1 Enhancement)
    workflowPhase: {
      type: String,
      enum: [
        "planning",
        "approval",
        "implementation",
        "execution",
        "completion",
      ],
      default: "planning",
    },
    workflowStep: {
      type: Number,
      default: 1,
      min: 1,
    },
    isAutoGenerated: {
      type: Boolean,
      default: false,
    },
    workflowTriggers: {
      inventoryCreated: { type: Boolean, default: false },
      procurementInitiated: { type: Boolean, default: false },
      financialSetup: { type: Boolean, default: false },
    },
    workflowHistory: [
      {
        phase: { type: String, required: true },
        action: { type: String, required: true },
        triggeredBy: {
          type: String,
          enum: ["manual", "auto"],
          default: "manual",
        },
        triggeredByUser: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        metadata: { type: mongoose.Schema.Types.Mixed },
        timestamp: { type: Date, default: Date.now },
      },
    ],

    // Approval Workflow
    approvalChain: [
      {
        level: {
          type: String,
          enum: ["hod", "department", "finance", "executive"],
          required: true,
        },
        approver: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "User",
        },
        department: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "Department",
        },
        status: {
          type: String,
          enum: ["pending", "approved", "rejected", "skipped"],
          default: "pending",
        },
        comments: {
          type: String,
          trim: true,
        },
        approvedAt: {
          type: Date,
        },
        required: {
          type: Boolean,
          default: true,
        },
      },
    ],

    // Documents for Project Approval
    requiredDocuments: [
      {
        documentType: {
          type: String,
          enum: [
            "project_proposal",
            "budget_breakdown",
            "technical_specifications",
            "risk_assessment",
            "timeline_detailed",
            "team_structure",
            "vendor_quotes",
            "legal_review",
            "financial_analysis",
            "other",
          ],
          required: true,
        },
        documentId: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "Document",
        },
        fileName: {
          type: String,
          trim: true,
        },
        fileUrl: {
          type: String,
        },
        isRequired: {
          type: Boolean,
          default: true,
        },
        isSubmitted: {
          type: Boolean,
          default: false,
        },
        submittedAt: {
          type: Date,
        },
        submittedBy: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "User",
        },
        // Document approval tracking through the chain
        approvalStatus: {
          type: String,
          enum: ["pending", "approved", "rejected", "skipped"],
          default: "pending",
        },
        approvalHistory: [
          {
            level: {
              type: String,
              enum: ["hod", "finance", "executive"],
              required: true,
            },
            approver: {
              type: mongoose.Schema.Types.ObjectId,
              ref: "User",
            },
            department: {
              type: mongoose.Schema.Types.ObjectId,
              ref: "Department",
            },
            status: {
              type: String,
              enum: ["pending", "approved", "rejected", "skipped"],
              default: "pending",
            },
            comments: {
              type: String,
              trim: true,
            },
            approvedAt: {
              type: Date,
            },
            // Document version at this approval level
            documentVersion: {
              type: Number,
              default: 1,
            },
            // Track if document was modified during this approval
            documentModified: {
              type: Boolean,
              default: false,
            },
            // Track document content hash for integrity
            documentHash: {
              type: String,
              trim: true,
            },
          },
        ],
        // Current approval level
        currentApprovalLevel: {
          type: String,
          enum: ["hod", "finance", "executive"],
          default: "hod",
        },
        // Track document modifications through approval chain
        documentVersions: [
          {
            version: {
              type: Number,
              required: true,
            },
            documentId: {
              type: mongoose.Schema.Types.ObjectId,
              ref: "Document",
            },
            fileName: {
              type: String,
              trim: true,
            },
            fileUrl: {
              type: String,
            },
            modifiedBy: {
              type: mongoose.Schema.Types.ObjectId,
              ref: "User",
            },
            modifiedAt: {
              type: Date,
              default: Date.now,
            },
            approvalLevel: {
              type: String,
              enum: ["hod", "finance", "executive"],
            },
            comments: {
              type: String,
              trim: true,
            },
            // Document content hash for integrity verification
            contentHash: {
              type: String,
              trim: true,
            },
          },
        ],
      },
    ],

    // Project Notes
    notes: [
      {
        content: {
          type: String,
          required: true,
          trim: true,
        },
        author: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "User",
          required: true,
        },
        createdAt: {
          type: Date,
          default: Date.now,
        },
        isPrivate: {
          type: Boolean,
          default: false,
        },
      },
    ],

    // Audit Fields
    createdBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    updatedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },

    isActive: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Indexes for better performance
projectSchema.index({ status: 1 });
projectSchema.index({ projectManager: 1 });
projectSchema.index({ "teamMembers.user": 1 });
projectSchema.index({ code: 1 }, { unique: true });
projectSchema.index({ startDate: 1, endDate: 1 });

// Virtual for project duration
projectSchema.virtual("duration").get(function () {
  if (this.actualStartDate && this.actualEndDate) {
    return Math.ceil(
      (this.actualEndDate - this.actualStartDate) / (1000 * 60 * 60 * 24)
    );
  }
  return Math.ceil((this.endDate - this.startDate) / (1000 * 60 * 60 * 24));
});

projectSchema.virtual("budgetVariance").get(function () {
  return this.budget - this.actualCost;
});

projectSchema.virtual("isOverdue").get(function () {
  if (this.status === "completed" || this.status === "cancelled") return false;
  return new Date() > this.endDate;
});

projectSchema.pre("save", async function (next) {
  try {
    if (!this.code) {
      // Department-based project numbering
      const currentYear = new Date().getFullYear();

      // Get department prefix
      const department = await mongoose
        .model("Department")
        .findById(this.department);
      const deptPrefix = department
        ? department.name.substring(0, 3).toUpperCase()
        : "PRJ";

      // Count projects for this department in current year
      const count = await this.constructor.countDocuments({
        department: this.department,
        createdAt: {
          $gte: new Date(currentYear, 0, 1),
          $lt: new Date(currentYear + 1, 0, 1),
        },
        isActive: true,
      });

      this.code = `${deptPrefix}${currentYear}${String(count + 1).padStart(
        4,
        "0"
      )}`;
    }

    // Set budget threshold based on budget amount and department
    if (this.budget && !this.budgetThreshold) {
      // Get department name for smart threshold determination
      let departmentName = "Unknown";
      try {
        const dept = await mongoose
          .model("Department")
          .findById(this.department);
        departmentName = dept ? dept.name : "Unknown";
      } catch (error) {
        console.error("Error getting department for budget threshold:", error);
      }

      if (this.budget <= 1000000) {
        // 1M NGN
        this.budgetThreshold = "hod_auto_approve";
      } else if (this.budget <= 5000000) {
        // 5M NGN - For Finance department, skip finance approval
        if (departmentName === "Finance & Accounting") {
          this.budgetThreshold = "executive_approval";
        } else {
          this.budgetThreshold = "department_approval";
        }
      } else if (this.budget <= 25000000) {
        // 25M NGN - For Finance department, skip finance approval
        if (departmentName === "Finance & Accounting") {
          this.budgetThreshold = "executive_approval";
        } else {
          this.budgetThreshold = "finance_approval";
        }
      } else {
        // Above 25M NGN
        this.budgetThreshold = "executive_approval";
      }
    }

    next();
  } catch (error) {
    next(error);
  }
});

// Post-save middleware for audit logging
projectSchema.post("save", async function (doc) {
  try {
    // Only log if this is a new project (not an update)
    if (doc.isNew) {
      // Get the user who created the project (from the request context)
      // This will be set by the controller
      const user = doc._createdBy;
      if (user) {
        await ProjectAuditService.logProjectCreated(doc, user);
      }
    }
  } catch (error) {
    console.error("❌ [AUDIT] Error in post-save audit logging:", error);
  }
});

projectSchema.statics.getProjectStats = async function () {
  const stats = await this.aggregate([
    { $match: { isActive: true } },
    {
      $group: {
        _id: "$status",
        count: { $sum: 1 },
        totalBudget: { $sum: "$budget" },
        totalActualCost: { $sum: "$actualCost" },
      },
    },
  ]);

  return stats.reduce((acc, stat) => {
    acc[stat._id] = {
      count: stat.count,
      totalBudget: stat.totalBudget,
      totalActualCost: stat.totalActualCost,
    };
    return acc;
  }, {});
};

// Static method to get active projects
projectSchema.statics.getActiveProjects = function () {
  return this.find({ isActive: true, status: "active" })
    .populate("projectManager", "firstName lastName email")
    .populate("teamMembers.user", "firstName lastName email")
    .sort({ startDate: 1 });
};

// Static method to get projects by category
projectSchema.statics.getByCategory = function (category) {
  return this.find({ isActive: true, category })
    .populate("projectManager", "firstName lastName email")
    .sort({ startDate: 1 });
};

// Instance method to add team member
projectSchema.methods.addTeamMember = async function (userId, role) {
  const existingMember = this.teamMembers.find(
    (member) => member.user.toString() === userId.toString()
  );

  if (existingMember) {
    existingMember.isActive = true;
    existingMember.role = role;
  } else {
    this.teamMembers.push({
      user: userId,
      role: role,
      assignedDate: new Date(),
      isActive: true,
    });
  }

  await this.save();
};

// Instance method to remove team member
projectSchema.methods.removeTeamMember = async function (userId) {
  const memberIndex = this.teamMembers.findIndex(
    (member) => member.user.toString() === userId.toString()
  );

  if (memberIndex !== -1) {
    this.teamMembers[memberIndex].isActive = false;
    await this.save();
  }
};

// Instance method to add note
projectSchema.methods.addNote = async function (
  content,
  authorId,
  isPrivate = false
) {
  this.notes.push({
    content,
    author: authorId,
    isPrivate,
    createdAt: new Date(),
  });

  await this.save();
};

// Instance method to get project summary
projectSchema.methods.getSummary = function () {
  const activeTeamMembers = this.teamMembers.filter(
    (member) => member.isActive
  ).length;

  return {
    id: this._id,
    name: this.name,
    code: this.code,
    status: this.status,
    progress: this.progress,
    budget: this.budget,
    actualCost: this.actualCost,
    budgetVariance: this.budgetVariance,
    duration: this.duration,
    isOverdue: this.isOverdue,
    teamSize: activeTeamMembers,
    startDate: this.startDate,
    endDate: this.endDate,
    budgetThreshold: this.budgetThreshold,
  };
};

// Instance method to progress workflow to next phase
projectSchema.methods.progressWorkflow = async function (
  newPhase,
  action,
  triggeredBy = "manual",
  triggeredByUser = null,
  metadata = {}
) {
  const phaseOrder = [
    "planning",
    "approval",
    "implementation",
    "execution",
    "completion",
  ];
  const currentPhaseIndex = phaseOrder.indexOf(this.workflowPhase);
  const newPhaseIndex = phaseOrder.indexOf(newPhase);

  if (newPhaseIndex < currentPhaseIndex) {
    throw new Error(
      `Cannot move backwards in workflow. Current: ${this.workflowPhase}, Attempted: ${newPhase}`
    );
  }

  // Update workflow state
  this.workflowPhase = newPhase;
  this.workflowStep = this.workflowStep + 1;

  // Add to workflow history
  this.workflowHistory.push({
    phase: newPhase,
    action: action,
    triggeredBy: triggeredBy,
    triggeredByUser: triggeredByUser,
    metadata: metadata,
    timestamp: new Date(),
  });

  await this.save();

  // Audit logging for phase change
  if (triggeredByUser) {
    try {
      await ProjectAuditService.logPhaseChanged(
        this,
        triggeredByUser,
        this.workflowPhase,
        newPhase
      );
    } catch (error) {
      console.error("❌ [AUDIT] Error logging phase change:", error);
    }
  }

  return this;
};

// Instance method to trigger post-approval workflow
projectSchema.methods.triggerPostApprovalWorkflow = async function (
  triggeredByUser
) {
  if (this.status !== "approved") {
    throw new Error(
      "Project must be approved before triggering post-approval workflow"
    );
  }

  console.log("🚀 [WORKFLOW] ========================================");
  console.log("🚀 [WORKFLOW] POST-APPROVAL WORKFLOW TRIGGERED");
  console.log("🚀 [WORKFLOW] ========================================");

  // Audit logging for workflow trigger
  if (triggeredByUser) {
    try {
      await ProjectAuditService.logWorkflowTriggered(
        this,
        triggeredByUser,
        "implementation"
      );
    } catch (error) {
      console.error("❌ [AUDIT] Error logging workflow trigger:", error);
    }
  }
  console.log(`📋 [WORKFLOW] Project: ${this.name} (${this.code})`);
  console.log(`📋 [WORKFLOW] Category: ${this.category}`);
  console.log(`📋 [WORKFLOW] Budget: ${this.budget}`);

  try {
    // Move to implementation phase
    await this.progressWorkflow(
      "implementation",
      "post_approval_triggered",
      "auto",
      triggeredByUser,
      {
        projectCode: this.code,
        budget: this.budget,
        category: this.category,
      }
    );

    // Set status to implementation
    this.status = "implementation";
    await this.save();

    // Phase 1: Inventory Integration
    console.log("📦 [WORKFLOW] Phase 1: Inventory Integration");
    await this.triggerInventoryCreation(triggeredByUser);

    // Phase 2: Procurement Automation
    console.log("🛒 [WORKFLOW] Phase 2: Procurement Automation");
    await this.triggerProcurementCreation(triggeredByUser);

    // Phase 3: Financial Integration
    console.log("💰 [WORKFLOW] Phase 3: Financial Integration");
    await this.triggerFinancialSetup(triggeredByUser);

    // Phase 4: Document Creation for Regulatory Compliance
    console.log("📄 [WORKFLOW] Phase 4: Creating Project Documents");
    await this.createProjectDocuments(triggeredByUser);

    // Phase 5: Task Creation for Execution
    console.log("📋 [WORKFLOW] Phase 5: Creating Project Tasks");
    await this.createProjectTasks(triggeredByUser);

    // Move to execution phase
    await this.progressWorkflow(
      "execution",
      "tasks_created",
      "auto",
      triggeredByUser,
      {
        projectCode: this.code,
        taskCount: this.teamMembers.length * 3,
      }
    );

    console.log("✅ [WORKFLOW] Post-approval workflow completed successfully");
    console.log("🚀 [WORKFLOW] ========================================");

    return this;
  } catch (error) {
    console.error("❌ [WORKFLOW] Error in post-approval workflow:", error);
    throw error;
  }
};

// Instance method to trigger inventory creation
projectSchema.methods.triggerInventoryCreation = async function (
  triggeredByUser
) {
  try {
    console.log(
      "📦 [INVENTORY] Creating inventory items for project:",
      this.code
    );

    // Mark inventory as created
    this.workflowTriggers.inventoryCreated = true;
    await this.save();

    // Audit logging for inventory creation
    if (triggeredByUser) {
      try {
        await ProjectAuditService.logInventoryCreated(this, triggeredByUser);
      } catch (error) {
        console.error("❌ [AUDIT] Error logging inventory creation:", error);
      }
    }

    console.log("✅ [INVENTORY] Inventory creation triggered successfully");
    return true;
  } catch (error) {
    console.error("❌ [INVENTORY] Error creating inventory:", error);
    throw error;
  }
};

// Instance method to trigger procurement creation
projectSchema.methods.triggerProcurementCreation = async function (
  triggeredByUser
) {
  try {
    console.log(
      "🛒 [PROCUREMENT] Creating procurement orders for project:",
      this.code
    );

    // Mark procurement as initiated
    this.workflowTriggers.procurementInitiated = true;
    await this.save();

    // Audit logging for procurement initiation
    if (triggeredByUser) {
      try {
        await ProjectAuditService.logProcurementInitiated(
          this,
          triggeredByUser
        );
      } catch (error) {
        console.error(
          "❌ [AUDIT] Error logging procurement initiation:",
          error
        );
      }
    }

    console.log("✅ [PROCUREMENT] Procurement creation triggered successfully");
    return true;
  } catch (error) {
    console.error("❌ [PROCUREMENT] Error creating procurement:", error);
    throw error;
  }
};

// Instance method to trigger financial setup
projectSchema.methods.triggerFinancialSetup = async function (triggeredByUser) {
  try {
    console.log(
      "💰 [FINANCE] Setting up financial tracking for project:",
      this.code
    );

    // Mark financial setup as complete
    this.workflowTriggers.financialSetup = true;
    await this.save();

    // Audit logging for financial setup
    if (triggeredByUser) {
      try {
        await ProjectAuditService.logFinancialSetup(this, triggeredByUser);
      } catch (error) {
        console.error("❌ [AUDIT] Error logging financial setup:", error);
      }
    }

    console.log("✅ [FINANCE] Financial setup triggered successfully");
    return true;
  } catch (error) {
    console.error("❌ [FINANCE] Error setting up financial tracking:", error);
    throw error;
  }
};

// Instance method to create project documents for regulatory compliance
projectSchema.methods.createProjectDocuments = async function (
  triggeredByUser
) {
  try {
    console.log(
      "📄 [DOCUMENTS] Creating project documents for regulatory compliance"
    );

    // Get the user who triggered this (for audit purposes)
    const User = mongoose.model("User");
    const user = await User.findById(triggeredByUser).populate(
      "role department"
    );

    // Create required documents
    const documents = await ProjectDocumentService.createProjectDocuments(
      this,
      user
    );

    // Create approval workflows for each document
    for (const document of documents) {
      try {
        await ProjectDocumentService.createDocumentApprovalWorkflow(
          document,
          this
        );
        console.log(
          `📋 [DOCUMENT WORKFLOW] Created approval workflow for: ${document.title}`
        );
      } catch (error) {
        console.error(
          `❌ [DOCUMENT WORKFLOW] Error creating workflow for ${document.title}:`,
          error
        );
      }
    }

    console.log(
      `✅ [DOCUMENTS] Created ${documents.length} documents with approval workflows`
    );
    return documents;
  } catch (error) {
    console.error("❌ [DOCUMENTS] Error creating project documents:", error);
    throw error;
  }
};

// Instance method to create project tasks for execution phase
projectSchema.methods.createProjectTasks = async function (triggeredByUser) {
  try {
    console.log("📋 [TASKS] Creating project tasks for execution phase");

    // Get project team members
    const teamMembers = this.teamMembers || [];

    // Define task templates based on project category
    const taskTemplates = this.getTaskTemplatesByCategory();

    // Create tasks for each team member
    let totalTasksCreated = 0;
    for (const member of teamMembers) {
      const memberTasks = this.generateMemberTasks(member, taskTemplates);
      totalTasksCreated += memberTasks.length;
      console.log(
        `📋 [TASKS] Created ${memberTasks.length} tasks for team member: ${member.user}`
      );
    }

    // Audit logging for tasks creation
    if (triggeredByUser) {
      try {
        await ProjectAuditService.logTasksCreated(
          this,
          triggeredByUser,
          totalTasksCreated
        );
      } catch (error) {
        console.error("❌ [AUDIT] Error logging tasks creation:", error);
      }
    }

    console.log("✅ [TASKS] Project tasks created successfully");
    return true;
  } catch (error) {
    console.error("❌ [TASKS] Error creating project tasks:", error);
    throw error;
  }
};

// Helper method to get task templates by project category
projectSchema.methods.getTaskTemplatesByCategory = function () {
  const templates = {
    equipment_lease: {
      inventory: [
        "Review equipment specifications",
        "Verify equipment availability",
        "Check maintenance requirements",
      ],
      procurement: [
        "Review vendor quotes",
        "Approve purchase orders",
        "Track delivery timeline",
      ],
      finance: [
        "Set up lease payment tracking",
        "Monitor equipment costs",
        "Generate lease reports",
      ],
    },
    vehicle_lease: {
      inventory: [
        "Review vehicle specifications",
        "Check vehicle availability",
        "Verify insurance requirements",
      ],
      procurement: [
        "Review lease agreements",
        "Approve vehicle procurement",
        "Track registration process",
      ],
      finance: [
        "Set up vehicle payment tracking",
        "Monitor insurance costs",
        "Generate vehicle reports",
      ],
    },
    software_development: {
      inventory: [
        "Review software requirements",
        "Check development tools",
        "Verify hosting requirements",
      ],
      procurement: [
        "Review development licenses",
        "Approve hosting services",
        "Track deployment timeline",
      ],
      finance: [
        "Set up development cost tracking",
        "Monitor licensing costs",
        "Generate project reports",
      ],
    },
  };

  return templates[this.category] || templates.equipment_lease;
};

// Helper method to generate tasks for a team member
projectSchema.methods.generateMemberTasks = function (member, templates) {
  const tasks = [];

  // Add inventory tasks
  templates.inventory.forEach((taskName) => {
    tasks.push({
      title: taskName,
      description: `${taskName} for project ${this.name}`,
      assignedTo: member.user,
      project: this._id,
      category: "inventory",
      priority: "medium",
      dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
      status: "pending",
    });
  });

  // Add procurement tasks
  templates.procurement.forEach((taskName) => {
    tasks.push({
      title: taskName,
      description: `${taskName} for project ${this.name}`,
      assignedTo: member.user,
      project: this._id,
      category: "procurement",
      priority: "high",
      dueDate: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000), // 14 days
      status: "pending",
    });
  });

  // Add finance tasks
  templates.finance.forEach((taskName) => {
    tasks.push({
      title: taskName,
      description: `${taskName} for project ${this.name}`,
      assignedTo: member.user,
      project: this._id,
      category: "finance",
      priority: "medium",
      dueDate: new Date(Date.now() + 21 * 24 * 60 * 60 * 1000), // 21 days
      status: "pending",
    });
  });

  return tasks;
};

// Instance method to apply workflow template based on project criteria
projectSchema.methods.applyWorkflowTemplate = async function () {
  try {
    console.log(
      "📋 [WORKFLOW TEMPLATE] Applying workflow template to project:",
      this.code
    );

    // Get the project creator's department name
    const projectDept = await mongoose
      .model("Department")
      .findById(this.department);
    const projectDeptName = projectDept ? projectDept.name : "Unknown";

    // Get appropriate workflow template
    const template =
      await WorkflowTemplateService.getWorkflowTemplateForProject(
        this.category,
        this.budget,
        projectDeptName
      );

    // Apply the template to the project
    const approvalChain =
      await WorkflowTemplateService.applyWorkflowTemplateToProject(
        this,
        template,
        this._createdBy
      );

    console.log(
      `✅ [WORKFLOW TEMPLATE] Applied template ${template.name} with ${approvalChain.length} approval steps`
    );
    return approvalChain;
  } catch (error) {
    console.error(
      "❌ [WORKFLOW TEMPLATE] Error applying workflow template:",
      error
    );
    // Fallback to default approval chain if template fails
    return await this.generateApprovalChain();
  }
};

// Instance method to generate approval chain with smart cross-department routing
projectSchema.methods.generateApprovalChain = async function () {
  const approvalChain = [];

  // HOD approval (always first)
  approvalChain.push({
    level: "hod",
    department: this.department,
    status: "pending",
    required: true,
  });

  // Get the project creator's department name
  const projectDept = await mongoose
    .model("Department")
    .findById(this.department);
  const projectDeptName = projectDept ? projectDept.name : "Unknown";

  console.log(`🏢 [APPROVAL] Project Department: ${projectDeptName}`);
  console.log(`💰 [APPROVAL] Project Budget: ${this.budget}`);

  // Smart cross-department routing based on budget and creator department
  if (this.budget <= 1000000) {
    // ≤ 1M: HOD auto-approves, no additional approvals needed
    console.log("✅ [APPROVAL] Budget ≤ 1M - HOD auto-approval only");
  } else if (this.budget <= 5000000) {
    // 1M - 5M: Smart routing based on creator department
    if (projectDeptName === "Finance & Accounting") {
      // Finance HOD → Executive (skip Finance approval since it's their own department)
      console.log("📋 [APPROVAL] Finance HOD → Executive (1M-5M)");
      const execDept = await mongoose
        .model("Department")
        .findOne({ name: "Executive Office" });
      if (execDept) {
        approvalChain.push({
          level: "executive",
          department: execDept._id,
          status: "pending",
          required: true,
        });
      }
    } else {
      // All other HODs → Finance → Executive
      console.log("📋 [APPROVAL] Other HOD → Finance → Executive (1M-5M)");
      const financeDept = await mongoose
        .model("Department")
        .findOne({ name: "Finance & Accounting" });
      if (financeDept) {
        approvalChain.push({
          level: "finance",
          department: financeDept._id,
          status: "pending",
          required: true,
        });
      }
      const execDept = await mongoose
        .model("Department")
        .findOne({ name: "Executive Office" });
      if (execDept) {
        approvalChain.push({
          level: "executive",
          department: execDept._id,
          status: "pending",
          required: true,
        });
      }
    }
  } else if (this.budget <= 25000000) {
    // 5M - 25M: Smart routing based on creator department
    if (projectDeptName === "Finance & Accounting") {
      // Finance HOD → Executive (skip Finance approval since it's their own department)
      console.log("💰 [APPROVAL] Finance HOD → Executive (5M-25M)");
      const execDept = await mongoose
        .model("Department")
        .findOne({ name: "Executive Office" });
      if (execDept) {
        approvalChain.push({
          level: "executive",
          department: execDept._id,
          status: "pending",
          required: true,
        });
      }
    } else {
      // All other HODs → Finance → Executive
      console.log("💰 [APPROVAL] Other HOD → Finance → Executive (5M-25M)");
      const financeDept = await mongoose
        .model("Department")
        .findOne({ name: "Finance & Accounting" });
      if (financeDept) {
        approvalChain.push({
          level: "finance",
          department: financeDept._id,
          status: "pending",
          required: true,
        });
      }
      const execDept = await mongoose
        .model("Department")
        .findOne({ name: "Executive Office" });
      if (execDept) {
        approvalChain.push({
          level: "executive",
          department: execDept._id,
          status: "pending",
          required: true,
        });
      }
    }
  } else {
    // > 25M: Smart routing based on creator department
    if (projectDeptName === "Finance & Accounting") {
      // Finance HOD → Executive (skip Finance approval since it's their own department)
      console.log("👔 [APPROVAL] Finance HOD → Executive (>25M)");
      const execDept = await mongoose
        .model("Department")
        .findOne({ name: "Executive Office" });
      if (execDept) {
        approvalChain.push({
          level: "executive",
          department: execDept._id,
          status: "pending",
          required: true,
        });
      }
    } else if (projectDeptName === "Executive Office") {
      // Executive HOD → Finance → Executive (Final Approval)
      console.log(
        "👔 [APPROVAL] Executive HOD → Finance → Executive Final (>25M)"
      );
      const financeDept = await mongoose
        .model("Department")
        .findOne({ name: "Finance & Accounting" });
      if (financeDept) {
        approvalChain.push({
          level: "finance",
          department: financeDept._id,
          status: "pending",
          required: true,
        });
      }
      // Executive final approval (different person than HOD)
      const execDept = await mongoose
        .model("Department")
        .findOne({ name: "Executive Office" });
      if (execDept) {
        approvalChain.push({
          level: "executive",
          department: execDept._id,
          status: "pending",
          required: true,
        });
      }
    } else {
      // All other HODs → Finance → Executive
      console.log("👔 [APPROVAL] Other HOD → Finance → Executive (>25M)");
      const financeDept = await mongoose
        .model("Department")
        .findOne({ name: "Finance & Accounting" });
      if (financeDept) {
        approvalChain.push({
          level: "finance",
          department: financeDept._id,
          status: "pending",
          required: true,
        });
      }
      const execDept = await mongoose
        .model("Department")
        .findOne({ name: "Executive Office" });
      if (execDept) {
        approvalChain.push({
          level: "executive",
          department: execDept._id,
          status: "pending",
          required: true,
        });
      }
    }
  }

  this.approvalChain = approvalChain;
  await this.save();

  console.log(
    `🎯 [APPROVAL] Generated chain with ${approvalChain.length} levels:`
  );
  approvalChain.forEach((step, index) => {
    console.log(`   Level ${index + 1}: ${step.level} (${step.department})`);
  });

  return approvalChain;
};

// Instance method to approve project
projectSchema.methods.approveProject = async function (
  approverId,
  level,
  comments = ""
) {
  const approvalStep = this.approvalChain.find(
    (step) => step.level === level && step.status === "pending"
  );

  if (!approvalStep) {
    throw new Error(`No pending approval found for level: ${level}`);
  }

  approvalStep.status = "approved";
  approvalStep.approver = approverId;
  approvalStep.comments = comments;
  approvalStep.approvedAt = new Date();

  // Check if all required approvals are complete
  const pendingApprovals = this.approvalChain.filter(
    (step) => step.required && step.status === "pending"
  );

  if (pendingApprovals.length === 0) {
    this.status = "approved";
  } else {
    // Set status based on next pending approval
    const nextApproval = pendingApprovals[0];
    switch (nextApproval.level) {
      case "department":
        this.status = "pending_department_approval";
        break;
      case "finance":
        this.status = "pending_finance_approval";
        break;
      case "executive":
        this.status = "pending_executive_approval";
        break;
    }
  }

  await this.save();
  return this;
};

// Instance method to reject project
projectSchema.methods.rejectProject = async function (
  rejecterId,
  level,
  comments = ""
) {
  const approvalStep = this.approvalChain.find(
    (step) => step.level === level && step.status === "pending"
  );

  if (!approvalStep) {
    throw new Error(`No pending approval found for level: ${level}`);
  }

  approvalStep.status = "rejected";
  approvalStep.approver = rejecterId;
  approvalStep.comments = comments;
  approvalStep.approvedAt = new Date();

  this.status = "rejected";
  await this.save();
  return this;
};

// Instance method to add required document
projectSchema.methods.addRequiredDocument = async function (
  documentType,
  documentId,
  fileName,
  fileUrl,
  submittedBy
) {
  const existingDoc = this.requiredDocuments.find(
    (doc) => doc.documentType === documentType
  );

  if (existingDoc) {
    existingDoc.documentId = documentId;
    existingDoc.fileName = fileName;
    existingDoc.fileUrl = fileUrl;
    existingDoc.isSubmitted = true;
    existingDoc.submittedAt = new Date();
    existingDoc.submittedBy = submittedBy;
  } else {
    this.requiredDocuments.push({
      documentType,
      documentId,
      fileName,
      fileUrl,
      isSubmitted: true,
      submittedAt: new Date(),
      submittedBy,
    });
  }

  await this.save();
  return this;
};

// Instance method to check if all required documents are submitted
projectSchema.methods.checkDocumentsComplete = function () {
  const requiredDocs = this.requiredDocuments.filter((doc) => doc.isRequired);
  const submittedDocs = requiredDocs.filter((doc) => doc.isSubmitted);
  return requiredDocs.length === submittedDocs.length;
};

const Project = mongoose.model("Project", projectSchema);

export default Project;
